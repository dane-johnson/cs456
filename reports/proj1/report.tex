\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{Dane Johnson}
\begin{document}
\title{CS-456 Project 1}
\author{Dane Johnson}
\maketitle
\newpage
\section{Motivation}

The motivation for this project is to use Quicksort and Mergesort algorithms to practice empirical analysis of algorithms.
This includes creating diagrams and statistics to prove my implementation of the algorithms is correct.

Additionally, this project will serve as an exercise in writing pseudocode, proving its correctness and using invariants.
\section{Algorithms}
\subsection{Quicksort}
\subsubsection{Pseudocode}
\begin{verbatim}
proc quicksort(A, start, end)
  if start < end
    pivot <- A[end]
    i <- start - 1 
    for j <- start to end - 1
      if A[j] < pivot
        i++
        swap A[i] and A[j]
    if A[end] < A[i + 1]
      swap A[end] and A[i + 1]
    quicksort(A, start, i)
    quicksort(A, i + 2, end)
\end{verbatim}
\subsubsection{Correctness Proof}
\begin{description}
\item [Invariant: ] Given $k$, a number between $start$ and $end$
  \begin{enumerate}
  \item If $start \leq k \leq i$ then $A[k] \leq pivot$
  \item If $i + 1 \leq k \leq j - 1$ then $A[k] > pivot$
  \item If $k = end$ then $A[k] = pivot$
  \end{enumerate}
\item [Initialization: ] Before the first loop, $start$ and $end$ are the same, so no values
  lie in this range. Therefore the only $k$ that may be chosen id $end$, which is trivially
  equivalent to $pivot$.
\item [Maintenence: ] Two cases exist.
  \begin{enumerate}
  \item If $A[j] > pivot$, we merely increment $j$, and the second condition holds for $A[j - 1]$ and all other
    entries are unchanged.
  \item If $A[j] \leq pivot$, $A[i]$ is swapped with $A[j]$. Incrementing $j$ then gives $A[i] < pivot$, which satifies
    the first condition.
  \end{enumerate}
\item [Termination: ] When the loop terminates $j = end$, and all values of the array now fall into one of the three
  conditions of the invariant.
\end{description}
\subsection{Quicksort (Array)}
\subsubsection{Benchmark Data}
\includegraphics[height=10cm]{quicksort_array}
\subsection{Quicksort (Linked List)}
\subsubsection{Benchmark Data}
\includegraphics[height=10cm]{quicksort_list}
\subsection{Mergesort (Array)}
\subsubsection{Pseudocode}
\begin{verbatim}
proc mergesort(A)
  if A.length > 1
    divide A into A1 and A2
    mergesort(A1)
    mergesort(A2)
    merge(A1, A2, A)
proc merge(A1, A2, A)
  i <- 0
  j <- 0
  while i < A1.length or j < A2.length
    if i = A1.length
      A[i + j] <- A2[j]
      j++
    else if j = A2.length
      A[i + j] <- A1[i]
      i++
    else if A1[i] > A2[j]
      A[i + j] <- A1[i]
      i++
    else 
      A[i + j] <- A2[j]
      j++     
\end{verbatim}
\subsubsection{Benchmark Data}
\includegraphics[height=10cm]{mergesort_array}
\subsection{Heapsort (Linked List)}
\subsubsection{Pseudocode}
\begin{verbatim}
proc mergesort(L)
  if L.next = nil
    divide L into L1 and L2
    mergesort(L1)
    mergesort(L2)
    merge(L, L1, L2)
proc merge(L, L1, L2)
  if L1.val < L2.val
    L.head <- L1
    L1 = L1.next
  else
    L.head <- L2
    L2 = L2.next
  while L1.next ~= nil or L2.next ~= nil
    if L1.next = nil
      L.next <- L2
      L2 <- L2.next
    else if L2.next = nil
      L.next <- L1
      L1 <- L1.next
    else if L1.val > L2.val
      L.next <- L2.next
      L2 <- L2.next
    else
      L.next <- L1
      L1 <- L1.next
\end{verbatim}
\subsubsection{Benchmark Data}
\includegraphics[height=10cm]{mergesort_list}
\section{Conclusion}
\end{document}
